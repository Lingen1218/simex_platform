##########################################################################
#                                                                        #
# Copyright (C) 2015, 2016 Carsten Fortmann-Grote                        #
# Contact: Carsten Fortmann-Grote <carsten.grote@xfel.eu>                #
#                                                                        #
# This file is part of simex_platform.                                   #
# simex_platform is free software: you can redistribute it and/or modify #
# it under the terms of the GNU General Public License as published by   #
# the Free Software Foundation, either version 3 of the License, or      #
# (at your option) any later version.                                    #
#                                                                        #
# simex_platform is distributed in the hope that it will be useful,      #
# but WITHOUT ANY WARRANTY; without even the implied warranty of         #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          #
# GNU General Public License for more details.                           #
#                                                                        #
# You should have received a copy of the GNU General Public License      #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.  #
#                                                                        #
##########################################################################

""" Module that holds the FEFFPhotonMatterInteractor class.

    @author : CFG
    @institution : XFEL
    @creation 20161011

"""
import h5py
import numpy
import os
import shutil
import stat
import subprocess
import sys
import tempfile

from distutils.spawn import find_executable

from SimEx.Calculators.AbstractPhotonInteractor import AbstractPhotonInteractor
from SimEx.Parameters.AbstractCalculatorParameters import AbstractCalculatorParameters
from SimEx.Utilities.Utilities import ALL_ELEMENTS

class FEFFPhotonMatterInteractor(AbstractPhotonInteractor):
    """
    Interface class for photon-matter interaction calculations using the FEFF code.
    """

    def __init__(self,  parameters=None, input_path=None, output_path=None):
        """
        Constructor for the FEFF photon interactor.

        :param parameters: Parameters that govern the PMI calculation.
        :type parameters: FEFFPhotonMatterInteractorParameters

        :param input_path: Location of data needed by the PMI calculation.
        :type input_path: str

        :param output_path: Where to store the data generated by the PMI calculation.
        :type output_path: str
        """

        # Handle default output_path
        if output_path is None:
            if not os.path.exists('pmi'):
                os.mkdir('pmi')
            if os.path.isfile( 'pmi' ):
                raise IOError( "A file named 'pmi' already exists, cowardly refusing to overwrite.")
            output_path = 'pmi/pmi_out_0000001.h5'

        # Initialize base class.
        super(FEFFPhotonMatterInteractor, self).__init__(parameters,input_path,output_path)

        self.__provided_data = []

        self.__expected_data = ['/data/arrEhor',
                                '/data/arrEver',
                                '/params/Mesh/nSlices',
                                '/params/Mesh/nx',
                                '/params/Mesh/ny',
                                '/params/Mesh/qxMax',
                                '/params/Mesh/qxMin',
                                '/params/Mesh/qyMax',
                                '/params/Mesh/qyMin',
                                '/params/Mesh/sliceMax',
                                '/params/Mesh/sliceMin',
                                '/params/Mesh/xMax',
                                '/params/xMin',
                                '/params/yMax',
                                '/params/yMin',
                                '/params/zCoord',
                                '/params/beamline/printout',
                                '/params/Rx',
                                '/params/Ry',
                                '/params/dRx',
                                '/params/dRy',
                                '/params/nval',
                                '/params/photonEnergy',
                                '/params/wDomain',
                                '/params/wEFieldUnit',
                                '/params/wFloatType',
                                '/params/wSpace',
                                '/params/xCentre',
                                '/params/yCentre',
                                '/info/package_version',
                                '/info/contact',
                                '/info/data_description',
                                '/info/method_description',
                                '/misc/xFWHM',
                                '/misc/yFWHM',
                                '/version',
                                ]


    def expectedData(self):
        """ Query for the data expected by the Interactor. """
        return self.__expected_data

    def providedData(self):
        """ Query for the data provided by the Interactor. """
        return self.__provided_data

    def backengine(self):
        """ This method drives the backengine code."""

        # Setup the working directory.
        self._setupWorkingDirectory()

        # Setup path to executable.
        self.path_to_executable = find_executable('feff85L')

        # Copy executable.
        shutil.copy2(self.path_to_executable, self.working_directory)

        # Write parameter deck.
        with open( os.path.join( self.working_directory, 'feff.inp'), 'w' ) as deck:
            self.parameters._serialize( deck )
            deck.close()

        # Execute the code.
        try:
            old_wd = os.getcwd()
            os.chdir( self.working_directory)
            command_line = 'feff85L'
            proc = subprocess.Popen( command_line, shell=True)
            proc.wait()

            # Return.

            os.chdir( old_wd )

        except:
            os.chdir( old_wd )
            return 1

        # Setup data object. This will be a h5py File object residing purely in memory until closed,
        # at which moment it will be written to disk.
        self.__data = h5py.File(self.output_path, driver='core', backing_store=True, mode='w' )

        # Read raw data files.
        atoms = numpy.loadtxt( os.path.join( self.working_directory, 'atoms.dat'), skiprows=2)
        xmu = numpy.loadtxt( os.path.join( self.working_directory, 'xmu.dat'), comments='#')
        chi = numpy.loadtxt( os.path.join( self.working_directory, 'chi.dat'), comments='#', usecols=(2,3))

        # Setup tree and write data on the fly.
        self.__data.create_dataset('data/snp_0000001/r', data=atoms[:,:3])
        #self.__data.create_dataset('data/snp_0000001/xyz', data=None)
        #self.__data.create_dataset('data/snp_0000001/Z', data=None)
        #self.__data.create_dataset('data/snp_0000001/T', data=None)
        self.__data.create_dataset('data/snp_0000001/E', data=xmu[:,0])
        self.__data.create_dataset('data/snp_0000001/DeltaE', data=xmu[:,1])
        self.__data.create_dataset('data/snp_0000001/k', data=xmu[:,2])
        self.__data.create_dataset('data/snp_0000001/mu', data=xmu[:,3])
        self.__data.create_dataset('data/snp_0000001/mu0', data=xmu[:,4])
        self.__data.create_dataset('data/snp_0000001/chi', data=xmu[:,5])
        self.__data.create_dataset('data/snp_0000001/ampl', data=chi[:,0])
        self.__data.create_dataset('data/snp_0000001/phase', data=chi[:,1])
        self.__data.create_dataset('data/snp_0000001/potential_index', data=atoms[:,3])

        self.__data['data/snp_0000001/r'].attrs['unit'] = 'Angstrom'
        self.__data['data/snp_0000001/DeltaE'].attrs['unit'] = 'eV'
        self.__data['data/snp_0000001/E'].attrs['unit'] = 'eV'
        self.__data['data/snp_0000001/k'].attrs['unit'] = '1'
        self.__data['data/snp_0000001/mu'].attrs['unit'] = '1/Angstrom'
        self.__data['data/snp_0000001/mu0'].attrs['unit'] = '1/Angstrom'
        self.__data['data/snp_0000001/chi'].attrs['unit'] = '1'
        self.__data['data/snp_0000001/ampl'].attrs['unit'] = '1'
        self.__data['data/snp_0000001/phase'].attrs['unit'] = 'rad'
        self.__data['data/snp_0000001/potential_index'].attrs['unit'] = '1'
        #self.__data.create_dataset('misc/polarization_tensor', data=None)
        #self.__data.create_dataset('misc/evec', data=None)
        #self.__data.create_dataset('misc/xivec', data=None)
        #self.__data.create_dataset('misc/spvec', data=None)
        #self.__data.create_dataset('misc/nabs', data=None)
        #self.__data.create_dataset('misc/iphabs', data=None)
        #self.__data.create_dataset('misc/cf_average_data', data=None)
        #self.__data.create_dataset('misc/ipol', data=None)
        #self.__data.create_dataset('misc/ispin', data=None)
        #self.__data.create_dataset('misc/le2', data=None)
        #self.__data.create_dataset('misc/elpty', data=None)
        #self.__data.create_dataset('misc/angks', data=None)

        return 0

    @property
    def data(self):
        """ Query for the field data. """
        return self.__data

    @property
    def working_directory(self):
        """ Query the working directory """
        return self.__working_directory
    @working_directory.setter
    def working_directory(self, value):
        """ Set the working directory to a value. """
        if not isinstance( value, str ):
            raise TypeError( "working_directory must be a string (path)." )

        if not os.path.isdir( value ):
            raise RuntimeError( "working_directory must be an existing directory (or link).")

        # All sane, set attribute.
        self.__working_directory = value

    @property
    def path_to_executable(self):
        """ Query the path to the feff executable. """
        return self.__path_to_executable
    @path_to_executable.setter
    def path_to_executable(self, value):
        """ Set the path_to_executable to a value. """
        # Check type.
        if not isinstance( value, str ):
            raise TypeError( "path_to_executable must be a string (path)." )
        # Check is file.
        if not os.path.isfile( value ):
            raise RuntimeError( "path_to_executable must be an existing file (or link).")
        # Check is executable.
        if not stat.S_IXUSR & os.stat(value)[stat.ST_MODE]:
            raise RuntimeError( "path_to_executable must be executable by the user.")

        # All sane, set attribute.
        self.__path_to_executable = value


    def _readH5(self):
        """ """
        """ Private method for reading the hdf5 input and extracting the parameters and data relevant to initialize the object. """
        pass # Nothing to be done since IO happens in backengine.

    def saveH5(self):
        """ """
        """
        Private method to save the object to a file.

        :param output_path: The file where to save the object's data. Default: self.output_path
        :type output_path: str
        """

        # Get the handle to the data.
        data = self.__data
        data.create_dataset('info/contact', data='Carsten Fortmann-Grote <carsten.grote@xfel.eu>')
        data.create_dataset('info/data_description', data='Absorption spectrum and associated data.')
        data.create_dataset('info/interface_version', data='1.0')
        data.create_dataset('info/credits', data='J. J. Rehr et al, "Ab initio theory and calculations of X-ray spectra", Comptes Rendus Physique _10_, 548 (2009). DOI: dx.doi.org/10.1016/j.crhy.2008.08.004')
        data.create_dataset('info/package_version', data='FEFF8.5L')

        data.create_dataset('params/edge', data=self.parameters.edge)
        data.create_dataset('params/amplitude_reduction_factor', data=self.parameters.amplitude_reduction_factor)
        data.create_dataset('params/effective_path_distance', data=self.parameters.effective_path_distance)
        data['params/amplitude_reduction_factor'].attrs['unit'] = '1'
        data['params/edge'].attrs['unit'] = ''
        data['params/effective_path_distance'].attrs['unit'] = 'Angstrom'

        # Close the dataset, this writes the data to disk.
        data.close()

    def _setupWorkingDirectory(self):
        """ Create a temporary directory where to execute the calculation. """

        self.working_directory = tempfile.mkdtemp(prefix='tmp_feff')

class FEFFPhotonMatterInteractorParameters(AbstractCalculatorParameters):
    """
    Interface class for photon-matter interaction calculations using the FEFF code.
    """

    def __init__(self,
            atoms=None,
            potentials=None,
            edge=None,
            amplitude_reduction_factor=None,
            effective_path_distance=None,
            ):
        """
        Constructor for the FEFF photon interactor.

        :param atoms: The atomic structure (Atom coordinates ([x,y,z] in Angstrom), element symbol, and potential index). If no potential index is given, all atoms of the same species will be assigned the default potential. The scattering atom must have the potential index 0.
        :type atoms: list || tuple
        :example atoms: ([[0.0, 0.0, 0.0], 'Cu', 0], [[0.0, 1.0, 1.2], 'O', 1], ...)

        :param potentials: The potentials to use.
        :type potentials: list

        :param edge: The edge to calculate (K, L1, L2, M1, M2, M3, ...). Default 'K'.
        :type edge: str

        :param amplitude_reduction_factor: The amplitude reduction factor. Default 1.0
        :type amplitude_reduction_factor: float

        :param effective_path_distance: The maximum effective (half-path) distance in Angstrom.  Translates to rpath parameter in feff.inp. Default 2.2 times nearest neighbor distance.
        :type effective_path_distance: float
        """

        # Initialize base class.
        super(FEFFPhotonMatterInteractorParameters, self).__init__()

        # Set the parameters. Type checking performed here.
        self.atoms = atoms
        self.potentials = potentials
        self.edge = edge
        self.amplitude_reduction_factor = amplitude_reduction_factor
        self.effective_path_distance = effective_path_distance

        # Finalize. This will check parameter consistency.
        self.finalize()

    # Queries and setters.
    @property
    def atoms(self):
        """ Query method for atoms """
        return self.__atoms
    @atoms.setter
    def atoms(self, value):
        """ Set self.__atoms to value. """
        # If all passed, set the member attribute.
        self.__atoms = _checkAndSetAtoms(value)
        self.__finalized = False

    @property
    def potentials(self):
        """ Query method for potentials """
        return self.__potentials
    @potentials.setter
    def potentials(self, value):
        """ Set self.__potentials to value. """
        self.__potentials = value
        self.__finalized = False

    @property
    def edge(self):
        """ Query method for edge """
        return self.__edge
    @edge.setter
    def edge(self, value):
        """ Set self.__edge to value. """
        if not isinstance(value, str):
            raise TypeError("Parameter 'edge' must be a string")
        if value in ['K', 'L1', 'L2', 'M1', 'M2', 'M3']:
            self.__edge = value
        else:
            raise ValueError("Parameter 'edge' must be one of 'K', 'L1', 'L2', 'M1', 'M2', or 'M3'.")
        self.__finalized = False

    @property
    def amplitude_reduction_factor(self):
        """ Query method for amplitude_reduction_factor """
        return self.__amplitude_reduction_factor
    @amplitude_reduction_factor.setter
    def amplitude_reduction_factor(self, value):
        """ Set self.__amplitude_reduction_factor to value. """

        try: # Cast int to float.
            value = float(value)
        except:
            raise TypeError("Parameter 'amplitude_reduction_factor' must be a float.")

        if ( value >=0.0 or value <= 1.0 ):
            self.__amplitude_reduction_factor = value
        else:
            raise TypeError("Parameter 'amplitude_reduction_factor' must obey 0.0 <= x <= 1.0.")

        self.__finalized = False

    @property
    def effective_path_distance(self):
        """ Query method for effective_path_distance """
        return self.__effective_path_distance
    @effective_path_distance.setter
    def effective_path_distance(self, value):
        """ Set self.__effective_path_distance to value. """
        try: # Cast int to float.
            value = float(value)
        except:
            raise TypeError("Parameter 'effective_path_distance' must be a float.")

        if ( value >=0.0):
            self.__effective_path_distance = value
        else:
            raise TypeError("Parameter 'effective_path_distance' must obey 0.0 <= x.")

        self.__finalized = False

    @property
    def finalized(self):
        """ Query the finalization status. """
        return self.__finalized

    def finalize(self):
        """ Finalize the parameters. Check if all parameters are internally consistent."""

        # Only if not finalized.
        if self.__finalized:
            return

        else:
            # Finalize potentials.
            self.__potential_list = []

            # Get atoms.
            atoms = self.atoms
            # Get potential indices.
            potential_indices = [atom[2] for atom in atoms]
            symbols = [atom[1] for atom in atoms]

            # Sort and set.
            unique_indices = set(potential_indices)

            # Loop over all unique potential indices and aggregate the potential information.
            for ui in unique_indices:
                index = potential_indices.index(ui)
                symbol = atoms[index][1] # Returns first found.
                atomic_number = ALL_ELEMENTS.index(symbol)+1
                self.__potential_list.append([ui, atomic_number, symbol])

            self.__finalized = True

    def _serialize(self, stream=sys.stdout ):
        """ """
        """ Private method to serialize the parameters, i.e. write the feff.inp file. """

        # Only possible if finalized.
        if not self.__finalized:
            raise RuntimeError("Only finalized parameters can be serialized. Call the finalize() method before serialize().")

        else:
            stream.write("EDGE    %s\n" % (self.edge) )
            stream.write("S02     %f\n" % (self.amplitude_reduction_factor) )
            stream.write("CONTROL 1 1 1 1 1 1\n")
            stream.write("PRINT   0 0 0 0 0 0\n")
            stream.write("RPATH   %f\n" % (self.effective_path_distance) )
            stream.write("EXAFS\n")
            stream.write("\n")
            stream.write("POTENTIALS\n")
            for potential in self.__potential_list:
                stream.write("%d      %d      %s\n" % (potential[0], potential[1], potential[2]) )
            stream.write("\n")
            stream.write("ATOMS\n")
            for atom in self.atoms:
                stream.write("%6.5f      %6.5f      %6.5f      %d\n" % (atom[0][0], atom[0][1], atom[0][2], atom[2]) )

            stream.write("END")
#
##########################################
# Utility functions

    def _setDefaults(self):
        """ """
        """ Set the inherited parameters defaults that depend on the special calculator. """
        self._AbstractCalculatorParameters__cpus_per_task_default = 1

def _checkAndSetAtoms(value):
    """ """
    """ Private function to check if input is a valid atoms list.

    :parameter value: The value to check.
    :return: The atom list if checks pass.
    :raises: Exception if input not a correct atom list.
    """
    # Check if None
    if value is None:
        raise TypeError( "Parameter 'atoms' must be an iterable (list or tuple) of length > 0")

    # Check if iterable.
    if not hasattr( value, '__iter__') or len(value) < 1:
        raise TypeError( "Parameter 'atoms' must be an iterable (list or tuple) of length > 0")

    # Check all elements.
    for atom in value:
        # Check that each atom is a list of tuple.
        if not ( isinstance(atom, list) or isinstance(atom, tuple)):
            raise TypeError( "Each element in 'atoms' must be a list or tuple.")

        # Check that first element is the coordinate vector.
        if not hasattr( atom[0], '__iter__' ) or not len(atom[0]) == 3:
            raise TypeError( "The first element in each element in 'atoms' must be an iterable of length 3 (atomic coordinates in Angstrom).")

        # Check that second element is the element symbol.
        if not isinstance( atom[1], str ):
            raise TypeError( "The second element in each element in 'atoms' must be a string (element symbol).")
        if not atom[1] in ALL_ELEMENTS:
            raise ValueError( "The second element in each element in 'atoms' must be a valid element symbol.")
        # Check that third element is the potential index.
        if not isinstance( atom[2], int ):
            raise TypeError( "The third element in each element in 'atoms' must be an integer (potential index).")

    ### Check potential indices.
    # Extract potential indices.
    potential_indices = [atom[2] for atom in value]
    # Sort.
    potential_indices.sort()

    # Check that there's only one index 0.
    if potential_indices[0] != 0 or 0 in potential_indices[1:]:
        raise ValueError( "There must be one and only one potential index 0.")

    # Get unique indices.
    unique_indices = set(potential_indices)

    # Check no indices missing.
    for i,ui in enumerate(unique_indices):
        if i != ui:
            raise ValueError( "Potential index %d is missing." % (i) )

    # All sane, return.
    return value

def _checkAndSetPotentials(value):
    """ """
    """ Check if value is a valid potential. Currently, only None is accepted, i.e. default FEFF potentials are used.

    :param value: The input to check.
    :raises TypeError: if input is not None.
    """

    if value is None:
        return value
    else:
        raise ValueError( "Parameter 'potentials' must be None.")

def _checkAndSetEdge( value):
    """ """
    """ Check input value if a valid edge.

    :param value: The value to check.
    :raises TypeError: if not a str.
    :raises ValueError: if not a valid edge designator ('K', 'L1', 'L2', 'M1', 'M2', 'M3', ...).
    :return: The checked edge designator.
    """

    # Check default.
    if value is None:
        return 'K'

    # Check if str.
    if not isinstance(value, str):
        raise TypeError( "Parameter 'edge' must be a string.")

    # Lower case is ok, convert to upper.
    value = value.upper()

    # Accepted edges.
    valid_edges = ['K', 'L1', 'L2', 'M1', 'M2', 'M3']

    # Check if valid edge.
    if not value in valid_edges:
        raise ValueError( "Parameter 'edge' must be one of %s. " % (str(valid_edges)) )

    # All sane, return.
    return value

def _checkAndSetAmplitudeReductionFactor(value):
    """ """
    """ Check input value for amplitude_reduction_factor.

    :param value: The value to check.
    :raises TypeError: if not a float (0, 1 ok.)
    :raises ValueError: if not in range [0, 1].
    :return: The checked amplitude reduction factor.
    """

    # Handle default.
    if value is None:
        return 1.0

    # Convert to float.
    if isinstance( value, int):
        value = float( value )

    # Check type.
    if not isinstance( value, float ):
        raise TypeError( "Parameter 'amplitude_reduction_factor' must be a float. ")

    # Check range.
    if ( value < 0.0 ) or ( value > 1.0 ):
        raise ValueError( "Parameter 'amplitude_reduction_factor' must obey 0 <= x <= 1.")

    # All sane, return
    return value

def _checkAndSetEffectivePathDistance(value):
    """ """
    """ Check input value for effective_path_distance.

    :param value: The value to check.
    :raises TypeError: if not a number.
    :raises ValueError: if not >= 0.
    :return: The checked effective path distance.
    """

    # Handle default.
    if value is None:
        return None

    # Convert to float.
    if isinstance( value, int):
        value = float( value )

    # Check type.
    if not isinstance( value, float ):
        raise TypeError( "Parameter 'effective_path_distance' must be a float. ")

    # Check range.
    if ( value < 0.0 ):
        raise ValueError( "Parameter 'effective_path_distance' must obey x >= 0.")

    # All sane, return
    return value

